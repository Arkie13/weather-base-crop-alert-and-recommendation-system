<?php
// Start output buffering FIRST to catch any unwanted output
if (!ob_get_level()) {
    ob_start();
}

// Disable error display but log errors instead
ini_set('display_errors', 0);
ini_set('log_errors', 1);
error_reporting(E_ALL);

// Require database config (do this BEFORE setting headers)
require_once __DIR__ . '/../config/database.php';
require_once __DIR__ . '/weather-helper.php';

// Start session for user authentication (only if not already started)
if (session_status() === PHP_SESSION_NONE) {
    session_start();
}

// Clean any output that might have been generated by includes
if (ob_get_level() > 0) {
    $output = ob_get_contents();
    if (!empty($output) && trim($output) !== '') {
        // Log any unexpected output
        error_log('Unexpected output before JSON: ' . substr($output, 0, 500));
        ob_clean();
    }
}

// Set headers AFTER cleaning output (to avoid "headers already sent" errors)
if (!headers_sent()) {
    header('Content-Type: application/json');
    header('Access-Control-Allow-Origin: *');
    header('Access-Control-Allow-Methods: GET, POST, OPTIONS');
    header('Access-Control-Allow-Headers: Content-Type');
}

class MarketTimingOptimizer {
    private $conn;
    private $weatherHelper;
    private $priceCache = []; // Cache for current prices to avoid repeated API calls
    
    // Crop database (same as crop-recommendation.php)
    private $cropDatabase = [
        'rice' => ['name' => 'Rice', 'growth_days' => 120, 'avg_yield_per_hectare' => 4000],
        'corn' => ['name' => 'Corn', 'growth_days' => 90, 'avg_yield_per_hectare' => 5000],
        'tomato' => ['name' => 'Tomato', 'growth_days' => 75, 'avg_yield_per_hectare' => 30000],
        'eggplant' => ['name' => 'Eggplant', 'growth_days' => 100, 'avg_yield_per_hectare' => 20000],
        'okra' => ['name' => 'Okra', 'growth_days' => 60, 'avg_yield_per_hectare' => 15000],
        'squash' => ['name' => 'Squash', 'growth_days' => 90, 'avg_yield_per_hectare' => 20000],
        'pepper' => ['name' => 'Pepper', 'growth_days' => 80, 'avg_yield_per_hectare' => 15000],
        'cabbage' => ['name' => 'Cabbage', 'growth_days' => 90, 'avg_yield_per_hectare' => 25000]
    ];
    
    public function __construct() {
        try {
            $database = new Database();
            $this->conn = $database->getConnection();
            if (!$this->conn) {
                throw new Exception('Database connection failed');
            }
        } catch (Exception $e) {
            error_log('MarketTimingOptimizer constructor - Database error: ' . $e->getMessage());
            throw new Exception('Failed to initialize database connection: ' . $e->getMessage());
        }
        
        try {
            // Check if WeatherHelper class exists before instantiating
            if (!class_exists('WeatherHelper')) {
                error_log('WeatherHelper class not found. Checking dependencies...');
                // Try to require weather-helper.php again if class doesn't exist
                if (file_exists(__DIR__ . '/weather-helper.php')) {
                    require_once __DIR__ . '/weather-helper.php';
                } else {
                    throw new Exception('weather-helper.php file not found');
                }
            }
            
            $this->weatherHelper = new WeatherHelper();
        } catch (Exception $e) {
            error_log('MarketTimingOptimizer constructor - WeatherHelper error: ' . $e->getMessage());
            error_log('WeatherHelper error trace: ' . $e->getTraceAsString());
            // Don't throw - allow the class to continue without weather helper
            // Weather functions will use fallbacks
            $this->weatherHelper = null;
        } catch (Error $e) {
            error_log('MarketTimingOptimizer constructor - WeatherHelper fatal error: ' . $e->getMessage());
            error_log('WeatherHelper fatal error trace: ' . $e->getTraceAsString());
            // Don't throw - allow the class to continue without weather helper
            $this->weatherHelper = null;
        }
    }
    
    public function getFarmersWithCrops() {
        try {
            // Get all farmers with their crop counts
            $query = "SELECT u.id, u.full_name, u.location, u.email, u.phone,
                     COUNT(DISTINCT uc.id) as crop_count,
                     COUNT(DISTINCT CASE WHEN uc.status IN ('planted', 'growing') 
                         AND uc.expected_harvest_date IS NOT NULL
                         AND uc.expected_harvest_date >= CURDATE()
                         AND uc.expected_harvest_date <= DATE_ADD(CURDATE(), INTERVAL 60 DAY)
                         THEN uc.id END) as upcoming_crop_count
                     FROM users u
                     LEFT JOIN user_crops uc ON u.id = uc.user_id
                     WHERE u.role = 'farmer'
                     GROUP BY u.id, u.full_name, u.location, u.email, u.phone
                     HAVING upcoming_crop_count > 0
                     ORDER BY u.full_name ASC";
            
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            $farmers = $stmt->fetchAll();
            
            return [
                'success' => true,
                'data' => [
                    'farmers' => $farmers
                ]
            ];
        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => 'Failed to fetch farmers: ' . $e->getMessage()
            ];
        }
    }
    
    public function getMarketTimingRecommendations($userId = null) {
        try {
            // Get user ID from session if not provided
            if (!$userId && isset($_SESSION['user_id'])) {
                $userId = $_SESSION['user_id'];
            }
            
            if (!$userId) {
                return [
                    'success' => false,
                    'message' => 'User not authenticated'
                ];
            }
            
            // Get current session user ID to check if admin
            $sessionUserId = $_SESSION['user_id'] ?? null;
            $isAdmin = $sessionUserId ? $this->isAdmin($sessionUserId) : false;
            
            // If userId parameter is provided and current user is admin, view that specific farmer's crops
            // Otherwise, if admin viewing without user_id, show all crops
            // If not admin, show only their own crops
            $targetUserId = $userId; // The userId parameter (could be a farmer ID if admin is viewing)
            
            if ($isAdmin && $targetUserId && $targetUserId != $sessionUserId) {
                // Admin viewing specific farmer's crops
                $upcomingCrops = $this->getUpcomingHarvests($targetUserId);
            } elseif ($isAdmin && !$targetUserId) {
                // Admin viewing all crops (when no specific user_id provided)
                $upcomingCrops = $this->getAllUpcomingHarvests();
            } else {
                // Regular user viewing their own crops, or admin viewing their own crops
                $upcomingCrops = $this->getUpcomingHarvests($targetUserId ? $targetUserId : $sessionUserId);
            }
            
            if (empty($upcomingCrops)) {
                return [
                    'success' => true,
                    'data' => [
                        'crops' => [],
                        'message' => $isAdmin ? 'No crops approaching harvest from any farmers' : 'No crops approaching harvest'
                    ]
                ];
            }
            
            $recommendations = [];
            
            foreach ($upcomingCrops as $crop) {
                try {
                    // Get location for the crop's owner (not the current user if admin)
                    $cropOwnerId = $crop['user_id'] ?? null;
                    if (!$cropOwnerId) {
                        error_log("Warning: Crop missing user_id, skipping: " . ($crop['id'] ?? 'unknown'));
                        continue;
                    }
                    
                    $userLocation = $this->getUserLocation($cropOwnerId);
                    
                    // Calculate optimal harvest date
                    $harvestTiming = $this->calculateOptimalHarvestDate($crop);
                    
                    // Analyze price trends
                    $priceAnalysis = $this->analyzePriceTrends($crop['crop_name'], $userLocation);
                    
                    // Calculate expected yield
                    $expectedYield = $crop['expected_yield_kg'] ?? 
                        ($this->getCropYield($crop['crop_name']) * ($crop['area_hectares'] ?? 1));
                    
                    // Calculate optimal sell date (use crop owner's storage capacity)
                    $sellTiming = $this->calculateOptimalSellDate(
                        $harvestTiming['optimal_date'],
                        $crop,
                        $expectedYield,
                        $this->getStorageCapacity($cropOwnerId)
                    );
                    
                    // Identify market opportunities
                    $opportunities = $this->identifyMarketOpportunities(
                        $crop['crop_name'],
                        $userLocation,
                        $harvestTiming['optimal_date']
                    );
                    
                    // Generate action items
                    $actionItems = $this->generateActionItems($harvestTiming, $sellTiming, $opportunities, $crop);
                    
                    // Get farmer info if admin
                    $farmerInfo = null;
                    if ($isAdmin) {
                        $farmerInfo = $this->getFarmerInfo($cropOwnerId);
                    }
                    
                    // Fetch real-time crop price per kilo (ALWAYS from API via crop-prices.php)
                    $currentPriceData = $this->getRealTimeCropPrice($crop['crop_name'], $userLocation);
                    
                    // Ensure we have price data (crop-prices.php should always return something)
                    if (!$currentPriceData) {
                        error_log("Warning: Failed to get price for crop: " . $crop['crop_name'] . " at location: " . $userLocation);
                        // Try one more time with default location
                        $currentPriceData = $this->getRealTimeCropPrice($crop['crop_name'], 'Manila');
                    }
                    
                    // Final fallback: use default price structure
                    if (!$currentPriceData) {
                        error_log("Critical: All price sources failed for crop: " . $crop['crop_name']);
                        $currentPriceData = [
                            'price_per_kg' => null,
                            'source' => 'error',
                            'date' => date('Y-m-d')
                        ];
                    }
                    
                    $recommendations[] = [
                        'crop_id' => $crop['id'],
                        'crop_name' => $crop['crop_name'],
                        'area_hectares' => $crop['area_hectares'] ?? 0,
                        'planting_date' => $crop['planting_date'] ?? null,
                        'current_status' => $crop['status'] ?? 'unknown',
                        'days_planted' => $crop['days_planted'] ?? 0,
                        'growth_days' => $this->getCropGrowthDays($crop['crop_name']),
                        'days_to_maturity' => $crop['days_to_maturity'] ?? 0,
                        'expected_yield_kg' => $expectedYield,
                        'harvest_timing' => $harvestTiming,
                        'sell_timing' => $sellTiming,
                        'price_analysis' => $priceAnalysis,
                        'market_opportunities' => $opportunities,
                        'action_items' => $actionItems,
                        'farmer_info' => $farmerInfo, // Only populated for admin
                        'current_price_per_kg' => $currentPriceData['price_per_kg'] ?? null,
                        'price_source' => $currentPriceData['source'] ?? 'default',
                        'price_date' => $currentPriceData['date'] ?? date('Y-m-d')
                    ];
                } catch (Exception $e) {
                    error_log("Error processing crop ID " . ($crop['id'] ?? 'unknown') . ": " . $e->getMessage());
                    error_log("Stack trace: " . $e->getTraceAsString());
                    // Continue processing other crops even if one fails
                    continue;
                } catch (Error $e) {
                    error_log("Fatal error processing crop ID " . ($crop['id'] ?? 'unknown') . ": " . $e->getMessage());
                    error_log("Stack trace: " . $e->getTraceAsString());
                    // Continue processing other crops even if one fails
                    continue;
                }
            }
            
            return [
                'success' => true,
                'data' => [
                    'farmer_id' => $isAdmin ? null : $userId,
                    'crops' => $recommendations,
                    'market_overview' => $this->getMarketOverview()
                ]
            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => 'Failed to generate recommendations: ' . $e->getMessage()
            ];
        }
    }
    
    private function getUpcomingHarvests($userId) {
        try {
            $query = "SELECT uc.*, 
                      DATEDIFF(CURDATE(), uc.planting_date) as days_planted,
                      DATEDIFF(uc.expected_harvest_date, CURDATE()) as days_to_maturity
                      FROM user_crops uc
                      WHERE uc.user_id = :user_id 
                      AND uc.status IN ('planted', 'growing')
                      AND uc.expected_harvest_date IS NOT NULL
                      AND uc.expected_harvest_date >= CURDATE()
                      AND uc.expected_harvest_date <= DATE_ADD(CURDATE(), INTERVAL 60 DAY)
                      ORDER BY uc.expected_harvest_date ASC";
            
            $stmt = $this->conn->prepare($query);
            $stmt->bindParam(':user_id', $userId);
            $stmt->execute();
            
            return $stmt->fetchAll(PDO::FETCH_ASSOC) ?: [];
        } catch (Exception $e) {
            error_log("Error fetching upcoming harvests for user $userId: " . $e->getMessage());
            return [];
        } catch (Error $e) {
            error_log("Fatal error fetching upcoming harvests for user $userId: " . $e->getMessage());
            return [];
        }
    }
    
    private function getAllUpcomingHarvests() {
        try {
            $query = "SELECT uc.*, 
                      DATEDIFF(CURDATE(), uc.planting_date) as days_planted,
                      DATEDIFF(uc.expected_harvest_date, CURDATE()) as days_to_maturity
                      FROM user_crops uc
                      INNER JOIN users u ON uc.user_id = u.id
                      WHERE u.role = 'farmer'
                      AND uc.status IN ('planted', 'growing')
                      AND uc.expected_harvest_date IS NOT NULL
                      AND uc.expected_harvest_date >= CURDATE()
                      AND uc.expected_harvest_date <= DATE_ADD(CURDATE(), INTERVAL 60 DAY)
                      ORDER BY uc.expected_harvest_date ASC";
            
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            
            return $stmt->fetchAll(PDO::FETCH_ASSOC) ?: [];
        } catch (Exception $e) {
            error_log("Error fetching all upcoming harvests: " . $e->getMessage());
            return [];
        } catch (Error $e) {
            error_log("Fatal error fetching all upcoming harvests: " . $e->getMessage());
            return [];
        }
    }
    
    private function isAdmin($userId) {
        $query = "SELECT role FROM users WHERE id = :user_id";
        $stmt = $this->conn->prepare($query);
        $stmt->bindParam(':user_id', $userId);
        $stmt->execute();
        $user = $stmt->fetch();
        
        return $user && $user['role'] === 'admin';
    }
    
    private function getFarmerInfo($userId) {
        $query = "SELECT id, full_name, location, email, phone FROM users WHERE id = :user_id";
        $stmt = $this->conn->prepare($query);
        $stmt->bindParam(':user_id', $userId);
        $stmt->execute();
        $farmer = $stmt->fetch();
        
        return $farmer ? [
            'id' => $farmer['id'],
            'name' => $farmer['full_name'],
            'location' => $farmer['location'],
            'email' => $farmer['email'],
            'phone' => $farmer['phone']
        ] : null;
    }
    
    private function getUserLocation($userId) {
        $query = "SELECT location FROM users WHERE id = :user_id";
        $stmt = $this->conn->prepare($query);
        $stmt->bindParam(':user_id', $userId);
        $stmt->execute();
        $user = $stmt->fetch();
        
        return $user['location'] ?? 'Manila';
    }
    
    private function calculateOptimalHarvestDate($crop) {
        try {
            $plantingDate = new DateTime($crop['planting_date']);
            $growthDays = $this->getCropGrowthDays($crop['crop_name']);
            
            // Base harvest date
            $baseHarvestDate = clone $plantingDate;
            $baseHarvestDate->modify("+{$growthDays} days");
            
            // Harvest window: Â±7 days from base date
            $harvestWindowStart = clone $baseHarvestDate;
            $harvestWindowStart->modify('-7 days');
            
            $harvestWindowEnd = clone $baseHarvestDate;
            $harvestWindowEnd->modify('+7 days');
            
            // Get user location for weather forecast
            $cropOwnerId = $crop['user_id'] ?? null;
            $userLocation = $this->getUserLocation($cropOwnerId);
            
            // Get real-time weather forecast from Open-Meteo API
            try {
                if ($this->weatherHelper) {
                    $weatherForecast = $this->getWeatherForecast(
                        $harvestWindowStart->format('Y-m-d'), 
                        $harvestWindowEnd->format('Y-m-d'),
                        $userLocation
                    );
                } else {
                    // WeatherHelper not available, use neutral forecast
                    $weatherForecast = [
                        'forecast_data' => [],
                        'dry_days' => [],
                        'rainy_days' => []
                    ];
                }
            } catch (Exception $e) {
                error_log("Error getting weather forecast for harvest timing: " . $e->getMessage());
                // Fallback to neutral forecast
                $weatherForecast = [
                    'forecast_data' => [],
                    'dry_days' => [],
                    'rainy_days' => []
                ];
            }
            
            $optimalDate = $baseHarvestDate->format('Y-m-d');
            $bestScore = 0;
            $reasoning = [];
            
            // Check each day in harvest window (limit to prevent infinite loops)
            $currentDate = clone $harvestWindowStart;
            $maxDays = 30; // Safety limit
            $dayCount = 0;
            
            while ($currentDate <= $harvestWindowEnd && $dayCount < $maxDays) {
                $dateStr = $currentDate->format('Y-m-d');
                $score = 0;
                
                try {
                    // Factor 1: Weather suitability (40% weight)
                    $weatherScore = $this->calculateHarvestWeatherScore($dateStr, $weatherForecast);
                    $score += $weatherScore * 0.40;
                    
                    // Factor 2: Market price on that date (35% weight)
                    $priceScore = $this->calculatePriceScore($crop['crop_name'], $dateStr);
                    $score += $priceScore * 0.35;
                    
                    // Factor 3: Crop maturity (25% weight)
                    $daysFromPlanting = $plantingDate->diff($currentDate)->days;
                    $maturityScore = $this->calculateMaturityScore($daysFromPlanting, $growthDays);
                    $score += $maturityScore * 0.25;
                    
                    if ($score > $bestScore) {
                        $bestScore = $score;
                        $optimalDate = $dateStr;
                    }
                } catch (Exception $e) {
                    error_log("Error calculating score for date $dateStr: " . $e->getMessage());
                    // Continue to next date
                }
                
                $currentDate->modify('+1 day');
                $dayCount++;
            }
        
        // Generate reasoning
        $optimalDateTime = new DateTime($optimalDate);
        $daysFromBase = $plantingDate->diff($optimalDateTime)->days;
        
        if ($daysFromBase == $growthDays) {
            $reasoning[] = "Crop will be at peak maturity ({$growthDays} days)";
        } elseif ($daysFromBase < $growthDays) {
            $reasoning[] = "Early harvest recommended for better market price";
        } else {
            $reasoning[] = "Slightly delayed harvest for optimal market conditions";
        }
        
            $reasoning[] = "Weather conditions favorable for harvest";
            $reasoning[] = "Market price expected to be optimal";
            
            return [
                'optimal_date' => $optimalDate,
                'harvest_window' => [
                    'start' => $harvestWindowStart->format('Y-m-d'),
                    'end' => $harvestWindowEnd->format('Y-m-d')
                ],
                'score' => round($bestScore, 2),
                'reasoning' => $reasoning
            ];
        } catch (Exception $e) {
            error_log("Error in calculateOptimalHarvestDate: " . $e->getMessage());
            // Return a safe default
            try {
                $plantingDate = new DateTime($crop['planting_date']);
                $growthDays = $this->getCropGrowthDays($crop['crop_name']);
                $baseHarvestDate = clone $plantingDate;
                $baseHarvestDate->modify("+{$growthDays} days");
                
                $harvestWindowStart = clone $baseHarvestDate;
                $harvestWindowStart->modify('-7 days');
                $harvestWindowEnd = clone $baseHarvestDate;
                $harvestWindowEnd->modify('+7 days');
                
                return [
                    'optimal_date' => $baseHarvestDate->format('Y-m-d'),
                    'harvest_window' => [
                        'start' => $harvestWindowStart->format('Y-m-d'),
                        'end' => $harvestWindowEnd->format('Y-m-d')
                    ],
                    'score' => 50,
                    'reasoning' => ['Using default harvest date calculation']
                ];
            } catch (Exception $e2) {
                error_log("Error in fallback calculation: " . $e2->getMessage());
                // Ultimate fallback
                return [
                    'optimal_date' => date('Y-m-d', strtotime('+90 days')),
                    'harvest_window' => [
                        'start' => date('Y-m-d', strtotime('+83 days')),
                        'end' => date('Y-m-d', strtotime('+97 days'))
                    ],
                    'score' => 50,
                    'reasoning' => ['Using fallback harvest date']
                ];
            }
        } catch (Error $e) {
            error_log("Fatal error in calculateOptimalHarvestDate: " . $e->getMessage());
            // Return a safe default
            try {
                $plantingDate = new DateTime($crop['planting_date']);
                $growthDays = $this->getCropGrowthDays($crop['crop_name']);
                $baseHarvestDate = clone $plantingDate;
                $baseHarvestDate->modify("+{$growthDays} days");
                
                $harvestWindowStart = clone $baseHarvestDate;
                $harvestWindowStart->modify('-7 days');
                $harvestWindowEnd = clone $baseHarvestDate;
                $harvestWindowEnd->modify('+7 days');
                
                return [
                    'optimal_date' => $baseHarvestDate->format('Y-m-d'),
                    'harvest_window' => [
                        'start' => $harvestWindowStart->format('Y-m-d'),
                        'end' => $harvestWindowEnd->format('Y-m-d')
                    ],
                    'score' => 50,
                    'reasoning' => ['Using default harvest date calculation']
                ];
            } catch (Exception $e2) {
                error_log("Error in fallback calculation: " . $e2->getMessage());
                // Ultimate fallback
                return [
                    'optimal_date' => date('Y-m-d', strtotime('+90 days')),
                    'harvest_window' => [
                        'start' => date('Y-m-d', strtotime('+83 days')),
                        'end' => date('Y-m-d', strtotime('+97 days'))
                    ],
                    'score' => 50,
                    'reasoning' => ['Using fallback harvest date']
                ];
            }
        }
    }
    
    private function calculateOptimalSellDate($harvestDate, $crop, $expectedYield, $storageCapacity) {
        try {
            $currentPrice = $this->getCurrentPrice($crop['crop_name']);
            $storageCostPerDay = $this->getStorageCost($crop['crop_name']);
            
            $recommendations = [];
            $harvestDateTime = new DateTime($harvestDate);
            
            // Analyze next 30 days
            for ($daysAfterHarvest = 0; $daysAfterHarvest <= 30; $daysAfterHarvest++) {
                $sellDate = clone $harvestDateTime;
                $sellDate->modify("+{$daysAfterHarvest} days");
                $sellDateStr = $sellDate->format('Y-m-d');
                
                $forecastPrice = $this->getForecastPrice($crop['crop_name'], $sellDateStr);
                
                // Calculate net revenue
                $grossRevenue = $forecastPrice * $expectedYield;
                $totalStorageCost = $storageCostPerDay * $daysAfterHarvest * ($expectedYield / 1000); // Cost per ton
                $netRevenue = $grossRevenue - $totalStorageCost;
                
                // Calculate ROI
                $immediateRevenue = $currentPrice * $expectedYield;
                $revenueIncrease = $netRevenue - $immediateRevenue;
                $roi = $immediateRevenue > 0 ? (($revenueIncrease / $immediateRevenue) * 100) : 0;
                
                $priceChangePercent = $currentPrice > 0 ? round((($forecastPrice - $currentPrice) / $currentPrice) * 100, 2) : 0;
                
                $recommendations[] = [
                    'sell_date' => $sellDateStr,
                    'days_after_harvest' => $daysAfterHarvest,
                    'forecast_price' => round($forecastPrice, 2),
                    'current_price' => round($currentPrice, 2),
                    'price_change' => round($forecastPrice - $currentPrice, 2),
                    'price_change_percent' => $priceChangePercent,
                    'gross_revenue' => round($grossRevenue, 2),
                    'storage_cost' => round($totalStorageCost, 2),
                    'net_revenue' => round($netRevenue, 2),
                    'roi' => round($roi, 2),
                    'risk_level' => $this->calculatePriceRisk($crop['crop_name'], $sellDateStr)
                ];
            }
            
            // Sort by net revenue
            usort($recommendations, function($a, $b) {
                return $b['net_revenue'] <=> $a['net_revenue'];
            });
            
            $optimal = $recommendations[0] ?? null;
            
            if (!$optimal) {
                throw new Exception("No recommendations generated");
            }
            
            return [
                'recommendation' => $optimal['days_after_harvest'] == 0 ? 'sell_immediately' : 'store_and_sell_later',
                'optimal_sell_date' => $optimal['sell_date'],
                'days_after_harvest' => $optimal['days_after_harvest'],
                'expected_revenue' => $optimal['net_revenue'],
                'price_improvement' => $optimal['price_change_percent'],
                'price_analysis' => [
                    'current_price' => $optimal['current_price'],
                    'optimal_price' => $optimal['forecast_price'],
                    'price_increase' => $optimal['price_change'],
                    'price_increase_percent' => $optimal['price_change_percent'],
                    'price_trend' => $optimal['price_change'] > 0 ? 'increasing' : 'decreasing'
                ],
                'revenue_calculation' => [
                    'immediate_sell' => [
                        'price_per_kg' => $optimal['current_price'],
                        'total_revenue' => round($optimal['current_price'] * $expectedYield, 2),
                        'storage_cost' => 0,
                        'net_revenue' => round($optimal['current_price'] * $expectedYield, 2)
                    ],
                    'optimal_sell' => [
                        'price_per_kg' => $optimal['forecast_price'],
                        'total_revenue' => round($optimal['forecast_price'] * $expectedYield, 2),
                        'storage_cost' => round($optimal['storage_cost'], 2),
                        'net_revenue' => round($optimal['net_revenue'], 2),
                        'additional_profit' => round($optimal['net_revenue'] - ($optimal['current_price'] * $expectedYield), 2),
                        'roi' => round($optimal['roi'], 2)
                    ]
                ],
                'storage_requirements' => [
                    'storage_days' => $optimal['days_after_harvest'],
                    'storage_capacity_needed_kg' => $expectedYield,
                    'storage_cost_per_day' => round($storageCostPerDay * ($expectedYield / 1000), 2),
                    'total_storage_cost' => round($optimal['storage_cost'], 2),
                    'storage_available' => $storageCapacity >= $expectedYield
                ],
                'all_options' => array_slice($recommendations, 0, 10) // Top 10 options
            ];
        } catch (Exception $e) {
            error_log("Error in calculateOptimalSellDate: " . $e->getMessage());
            // Return a safe default response
            return [
                'recommendation' => 'sell_immediately',
                'optimal_sell_date' => $harvestDate,
                'days_after_harvest' => 0,
                'expected_revenue' => 0,
                'price_improvement' => 0,
                'price_analysis' => [
                    'current_price' => 0,
                    'optimal_price' => 0,
                    'price_increase' => 0,
                    'price_increase_percent' => 0,
                    'price_trend' => 'stable'
                ],
                'revenue_calculation' => [
                    'immediate_sell' => [
                        'price_per_kg' => 0,
                        'total_revenue' => 0,
                        'storage_cost' => 0,
                        'net_revenue' => 0
                    ],
                    'optimal_sell' => [
                        'price_per_kg' => 0,
                        'total_revenue' => 0,
                        'storage_cost' => 0,
                        'net_revenue' => 0,
                        'additional_profit' => 0,
                        'roi' => 0
                    ]
                ],
                'storage_requirements' => [
                    'storage_days' => 0,
                    'storage_capacity_needed_kg' => $expectedYield,
                    'storage_cost_per_day' => 0,
                    'total_storage_cost' => 0,
                    'storage_available' => true
                ],
                'all_options' => []
            ];
        } catch (Error $e) {
            error_log("Fatal error in calculateOptimalSellDate: " . $e->getMessage());
            // Return a safe default response
            return [
                'recommendation' => 'sell_immediately',
                'optimal_sell_date' => $harvestDate,
                'days_after_harvest' => 0,
                'expected_revenue' => 0,
                'price_improvement' => 0,
                'price_analysis' => [
                    'current_price' => 0,
                    'optimal_price' => 0,
                    'price_increase' => 0,
                    'price_increase_percent' => 0,
                    'price_trend' => 'stable'
                ],
                'revenue_calculation' => [
                    'immediate_sell' => [
                        'price_per_kg' => 0,
                        'total_revenue' => 0,
                        'storage_cost' => 0,
                        'net_revenue' => 0
                    ],
                    'optimal_sell' => [
                        'price_per_kg' => 0,
                        'total_revenue' => 0,
                        'storage_cost' => 0,
                        'net_revenue' => 0,
                        'additional_profit' => 0,
                        'roi' => 0
                    ]
                ],
                'storage_requirements' => [
                    'storage_days' => 0,
                    'storage_capacity_needed_kg' => $expectedYield,
                    'storage_cost_per_day' => 0,
                    'total_storage_cost' => 0,
                    'storage_available' => true
                ],
                'all_options' => []
            ];
        }
    }
    
    private function analyzePriceTrends($cropName, $location, $daysAhead = 30) {
        // Get historical prices
        $query = "SELECT date, price_per_kg, demand_level 
                  FROM market_prices 
                  WHERE crop_name = :crop AND location = :location 
                  AND date >= DATE_SUB(CURDATE(), INTERVAL 90 DAY)
                  ORDER BY date ASC
                  LIMIT 30";
        
        $stmt = $this->conn->prepare($query);
        $stmt->bindParam(':crop', $cropName);
        $stmt->bindParam(':location', $location);
        $stmt->execute();
        $historicalPrices = $stmt->fetchAll();
        
        // Format historical prices for frontend
        $historical = [];
        foreach ($historicalPrices as $price) {
            $historical[] = [
                'date' => $price['date'],
                'price' => (float)$price['price_per_kg'],
                'demand_level' => $price['demand_level'] ?? 'medium'
            ];
        }
        
        // Calculate price change and trend from historical data
        $priceChange = 0;
        $priceChangePercent = 0;
        $trendDirection = 'stable';
        if (count($historical) >= 2) {
            $oldestPrice = $historical[0]['price'];
            $latestPrice = $historical[count($historical) - 1]['price'];
            $priceChange = $latestPrice - $oldestPrice;
            $priceChangePercent = $oldestPrice > 0 ? (($priceChange / $oldestPrice) * 100) : 0;
            
            if ($priceChangePercent > 5) {
                $trendDirection = 'increasing';
            } elseif ($priceChangePercent < -5) {
                $trendDirection = 'decreasing';
            }
        }
        
        // Get current price
        $currentPrice = $this->getCurrentPrice($cropName);
        
        // Get seasonal pattern
        $month = (int)date('n');
        $seasonalPattern = $this->getSeasonalPattern($cropName, $location, $month);
        
        // Generate forecasts
        $forecasts = [];
        for ($i = 0; $i <= $daysAhead; $i++) {
            $forecastDate = date('Y-m-d', strtotime("+{$i} days"));
            $forecastMonth = (int)date('n', strtotime($forecastDate));
            
            // Simple trend calculation
            $trendPrice = $currentPrice * (1 + ($seasonalPattern['price_multiplier'] - 1) * ($i / 30));
            
            $forecasts[] = [
                'date' => $forecastDate,
                'predicted_price' => round($trendPrice, 2),
                'confidence' => max(50, 100 - ($i * 2)) // Decreasing confidence over time
            ];
        }
        
        return [
            'current_price' => $currentPrice,
            'historical_prices' => $historical,
            'price_change' => round($priceChange, 2),
            'price_change_percent' => round($priceChangePercent, 2),
            'trend' => [
                'direction' => $trendDirection !== 'stable' ? $trendDirection : ($seasonalPattern['price_multiplier'] > 1 ? 'increasing' : 'stable'),
                'confidence' => 75
            ],
            'forecasts' => $forecasts
        ];
    }
    
    private function identifyMarketOpportunities($cropName, $location, $harvestDate) {
        $opportunities = [];
        $valleys = [];
        
        // Get price forecasts
        $priceAnalysis = $this->analyzePriceTrends($cropName, $location, 60);
        $forecasts = $priceAnalysis['forecasts'];
        
        $avgPrice = array_sum(array_column($forecasts, 'predicted_price')) / count($forecasts);
        
        foreach ($forecasts as $forecast) {
            if ($forecast['predicted_price'] >= $avgPrice * 1.20) {
                $opportunities[] = [
                    'date' => $forecast['date'],
                    'price' => $forecast['predicted_price'],
                    'premium' => round((($forecast['predicted_price'] - $avgPrice) / $avgPrice) * 100, 2),
                    'reason' => $this->explainPricePeak($forecast['date'], $cropName),
                    'action' => 'sell_on_this_date'
                ];
            } elseif ($forecast['predicted_price'] <= $avgPrice * 0.85) {
                $valleys[] = [
                    'date' => $forecast['date'],
                    'price' => $forecast['predicted_price'],
                    'discount' => round((($avgPrice - $forecast['predicted_price']) / $avgPrice) * 100, 2),
                    'action' => 'avoid_selling'
                ];
            }
        }
        
        return [
            'opportunities' => array_slice($opportunities, 0, 5),
            'valleys' => array_slice($valleys, 0, 3),
            'average_price' => round($avgPrice, 2)
        ];
    }
    
    private function generateActionItems($harvestTiming, $sellTiming, $opportunities, $crop) {
        $actionItems = [];
        
        $harvestDate = new DateTime($harvestTiming['optimal_date']);
        $today = new DateTime();
        $daysUntilHarvest = $today->diff($harvestDate)->days;
        
        if ($daysUntilHarvest <= 7) {
            $actionItems[] = [
                'priority' => 'high',
                'action' => 'Prepare for harvest on ' . $harvestTiming['optimal_date'],
                'deadline' => date('Y-m-d', strtotime($harvestTiming['optimal_date'] . ' -1 day')),
                'details' => 'Ensure harvesting equipment ready, check weather forecast'
            ];
        }
        
        if ($sellTiming['days_after_harvest'] > 0) {
            $actionItems[] = [
                'priority' => 'high',
                'action' => 'Reserve storage space for ' . $sellTiming['days_after_harvest'] . ' days',
                'deadline' => $harvestTiming['optimal_date'],
                'details' => 'Contact storage facility, capacity needed: ' . number_format($sellTiming['storage_requirements']['storage_capacity_needed_kg'], 0) . ' kg'
            ];
        }
        
        if (!empty($opportunities['opportunities'])) {
            $bestOpportunity = $opportunities['opportunities'][0];
            $actionItems[] = [
                'priority' => 'critical',
                'action' => 'Sell on ' . $bestOpportunity['date'] . ' for maximum profit',
                'deadline' => $bestOpportunity['date'],
                'details' => 'Expected price: PHP ' . $bestOpportunity['price'] . '/kg, potential profit: PHP ' . number_format($sellTiming['revenue_calculation']['optimal_sell']['additional_profit'], 2)
            ];
        }
        
        $actionItems[] = [
            'priority' => 'medium',
            'action' => 'Monitor price trends daily',
            'deadline' => 'ongoing',
            'details' => 'Check market prices, adjust sell date if price drops significantly'
        ];
        
        return $actionItems;
    }
    
    // Helper methods
    private function getCropGrowthDays($cropName) {
        $cropKey = strtolower(str_replace(' ', '_', $cropName));
        return $this->cropDatabase[$cropKey]['growth_days'] ?? 90;
    }
    
    private function getCropYield($cropName) {
        $cropKey = strtolower(str_replace(' ', '_', $cropName));
        return $this->cropDatabase[$cropKey]['avg_yield_per_hectare'] ?? 3000;
    }
    
    /**
     * Get current price - ALWAYS prioritizes real-time API from crop-prices.php
     * Uses caching to avoid repeated API calls
     */
    private function getCurrentPrice($cropName) {
        // Check cache first
        if (isset($this->priceCache[$cropName])) {
            return $this->priceCache[$cropName];
        }
        
        $price = null;
        
        // ALWAYS try crop-prices.php first (it handles APIs, dynamic calculation, etc.)
        if (file_exists(__DIR__ . '/crop-prices.php')) {
            try {
                // Only include if class doesn't exist yet
                if (!class_exists('CropPricesAPI')) {
                    // Use output buffering to catch any unwanted output
                    ob_start();
                    require_once __DIR__ . '/crop-prices.php';
                    $output = ob_get_clean();
                    // Log any unexpected output
                    if (!empty(trim($output))) {
                        error_log('Unexpected output from crop-prices.php: ' . substr($output, 0, 200));
                    }
                }
                
                $cropPricesAPI = new CropPricesAPI();
                // Use default location 'Manila' for API call
                $apiResult = $cropPricesAPI->getCurrentPrice($cropName, 'Manila');
                
                if ($apiResult && isset($apiResult['success']) && $apiResult['success'] && isset($apiResult['price_per_kg'])) {
                    $price = (float)$apiResult['price_per_kg'];
                }
            } catch (Exception $e) {
                error_log("Failed to fetch price from crop-prices API: " . $e->getMessage());
            } catch (Error $e) {
                error_log("Fatal error fetching price from crop-prices API: " . $e->getMessage());
            }
        }
        
        // Fallback to database only if API completely fails
        if ($price === null) {
            try {
                $query = "SELECT price_per_kg FROM market_prices 
                          WHERE crop_name = :crop 
                          ORDER BY date DESC LIMIT 1";
                $stmt = $this->conn->prepare($query);
                $stmt->bindParam(':crop', $cropName);
                $stmt->execute();
                $priceData = $stmt->fetch();
                
                if ($priceData && isset($priceData['price_per_kg'])) {
                    $price = (float)$priceData['price_per_kg'];
                }
            } catch (Exception $e) {
                error_log("Database query failed for price: " . $e->getMessage());
            }
        }
        
        // Last resort: Try crop-prices.php again (it should always return something)
        // crop-prices.php has built-in fallbacks (calculated prices, seasonal adjustments, etc.)
        if ($price === null && file_exists(__DIR__ . '/crop-prices.php') && class_exists('CropPricesAPI')) {
            try {
                $cropPricesAPI = new CropPricesAPI();
                $apiResult = $cropPricesAPI->getCurrentPrice($cropName, 'Manila');
                // crop-prices.php always returns a price (even if calculated)
                if ($apiResult && isset($apiResult['price_per_kg'])) {
                    $price = (float)$apiResult['price_per_kg'];
                }
            } catch (Exception $e) {
                error_log("Second attempt to fetch price failed: " . $e->getMessage());
            } catch (Error $e) {
                error_log("Fatal error in second attempt to fetch price: " . $e->getMessage());
            }
        }
        
        // Final fallback: use default price
        if ($price === null || $price <= 0) {
            error_log("CRITICAL ERROR: All price sources failed for crop: $cropName - using default");
            // Use a default price based on crop type
            $defaultPrices = [
                'Rice' => 25.50,
                'Corn' => 18.50,
                'Tomato' => 35.00,
                'Eggplant' => 20.00,
                'Okra' => 15.00,
                'Squash' => 20.00,
                'Pepper' => 15.00,
                'Cabbage' => 25.00
            ];
            $price = $defaultPrices[$cropName] ?? 20.00;
        }
        
        // Cache the price
        $this->priceCache[$cropName] = $price;
        
        return $price;
    }
    
    /**
     * Get real-time crop price per kilo with source information
     * ALWAYS prioritizes real-time API prices from crop-prices.php
     */
    private function getRealTimeCropPrice($cropName, $location = 'Manila') {
        try {
            // ALWAYS try to fetch from crop prices API first (this handles all APIs, dynamic calculation, etc.)
            if (file_exists(__DIR__ . '/crop-prices.php')) {
                // Only include if class doesn't exist yet
                if (!class_exists('CropPricesAPI')) {
                    // Use output buffering to catch any unwanted output
                    ob_start();
                    require_once __DIR__ . '/crop-prices.php';
                    $output = ob_get_clean();
                    // Log any unexpected output
                    if (!empty(trim($output))) {
                        error_log('Unexpected output from crop-prices.php: ' . substr($output, 0, 200));
                    }
                }
                
                $cropPricesAPI = new CropPricesAPI();
                $apiResult = $cropPricesAPI->getCurrentPrice($cropName, $location);
                
                // If API returns success, use it (even if it's calculated/dynamic, it's better than defaults)
                if ($apiResult && isset($apiResult['success']) && $apiResult['success'] && isset($apiResult['price_per_kg'])) {
                    return [
                        'price_per_kg' => (float)$apiResult['price_per_kg'],
                        'source' => $apiResult['source'] ?? 'api',
                        'date' => $apiResult['date'] ?? date('Y-m-d')
                    ];
                }
            }
            
            // Only fallback to database if crop-prices.php completely fails
            $query = "SELECT price_per_kg, date FROM market_prices 
                      WHERE crop_name = :crop 
                      ORDER BY date DESC LIMIT 1";
            $stmt = $this->conn->prepare($query);
            $stmt->bindParam(':crop', $cropName);
            $stmt->execute();
            $price = $stmt->fetch();
            
            if ($price) {
                return [
                    'price_per_kg' => (float)$price['price_per_kg'],
                    'source' => 'database',
                    'date' => $price['date'] ?? date('Y-m-d')
                ];
            }
            
            // Last resort: Let crop-prices.php handle defaults (it has better logic)
            // This should rarely happen as crop-prices.php should always return something
            if (file_exists(__DIR__ . '/crop-prices.php') && class_exists('CropPricesAPI')) {
                $cropPricesAPI = new CropPricesAPI();
                $apiResult = $cropPricesAPI->getCurrentPrice($cropName, $location);
                if ($apiResult && isset($apiResult['price_per_kg'])) {
                    return [
                        'price_per_kg' => (float)$apiResult['price_per_kg'],
                        'source' => $apiResult['source'] ?? 'calculated',
                        'date' => $apiResult['date'] ?? date('Y-m-d')
                    ];
                }
            }
            
            // This should never happen as crop-prices.php should always return something
            // But if it does, return null to indicate failure
            error_log("ERROR: All price sources failed for crop: $cropName - crop-prices.php should handle this");
            return null;
        } catch (Exception $e) {
            error_log("Exception in getRealTimeCropPrice: " . $e->getMessage());
            return null;
        } catch (Error $e) {
            error_log("Fatal error in getRealTimeCropPrice: " . $e->getMessage());
            return null;
        }
    }
    
    private function getForecastPrice($cropName, $date) {
        try {
            // Check if forecast exists
            $query = "SELECT predicted_price FROM price_forecasts 
                      WHERE crop_name = :crop AND forecast_date = :date
                      ORDER BY created_at DESC LIMIT 1";
            $stmt = $this->conn->prepare($query);
            $stmt->bindParam(':crop', $cropName);
            $stmt->bindParam(':date', $date);
            $stmt->execute();
            $forecast = $stmt->fetch();
            
            if ($forecast && isset($forecast['predicted_price'])) {
                return (float)$forecast['predicted_price'];
            }
            
            // Generate forecast based on seasonal pattern
            $currentPrice = $this->getCurrentPrice($cropName);
            $month = (int)date('n', strtotime($date));
            $pattern = $this->getSeasonalPattern($cropName, 'Manila', $month);
            
            $multiplier = $pattern['price_multiplier'] ?? 1.0;
            return $currentPrice * $multiplier;
        } catch (Exception $e) {
            error_log("Error in getForecastPrice: " . $e->getMessage());
            // Fallback to current price
            return $this->getCurrentPrice($cropName);
        } catch (Error $e) {
            error_log("Fatal error in getForecastPrice: " . $e->getMessage());
            // Fallback to current price
            return $this->getCurrentPrice($cropName);
        }
    }
    
    private function getSeasonalPattern($cropName, $location, $month) {
        $query = "SELECT avg_price_multiplier, avg_demand_level 
                  FROM market_demand_patterns 
                  WHERE crop_name = :crop AND location = :location AND month = :month";
        $stmt = $this->conn->prepare($query);
        $stmt->bindParam(':crop', $cropName);
        $stmt->bindParam(':location', $location);
        $stmt->bindParam(':month', $month);
        $stmt->execute();
        $pattern = $stmt->fetch();
        
        if ($pattern) {
            return [
                'price_multiplier' => (float)$pattern['avg_price_multiplier'],
                'demand_level' => $pattern['avg_demand_level']
            ];
        }
        
        // Default pattern
        return [
            'price_multiplier' => 1.0,
            'demand_level' => 'medium'
        ];
    }
    
    private function getStorageCapacity($userId) {
        $query = "SELECT SUM(capacity_kg - current_storage_kg) as available_capacity 
                  FROM storage_facilities 
                  WHERE user_id = :user_id";
        $stmt = $this->conn->prepare($query);
        $stmt->bindParam(':user_id', $userId);
        $stmt->execute();
        $result = $stmt->fetch();
        
        return $result['available_capacity'] ?? 10000; // Default 10 tons
    }
    
    private function getStorageCost($cropName) {
        // Storage cost per day per ton (PHP)
        $costs = [
            'Rice' => 50,
            'Corn' => 45,
            'Tomato' => 100,
            'Eggplant' => 80,
            'Okra' => 70,
            'Squash' => 60,
            'Pepper' => 90,
            'Cabbage' => 55
        ];
        
        return $costs[$cropName] ?? 60;
    }
    
    /**
     * Get weather forecast using real-time API
     * @param string $startDate Y-m-d format
     * @param string $endDate Y-m-d format
     * @param string $location Location name (e.g., "Manila, Philippines")
     * @return array Forecast data with dates, rainfall, wind, temperature
     */
    private function getWeatherForecast($startDate, $endDate, $location = 'Manila') {
        try {
            // Check if weather helper is available
            if (!$this->weatherHelper) {
                error_log("WeatherHelper not available, using fallback forecast");
                return [
                    'forecast_data' => [],
                    'dry_days' => [],
                    'rainy_days' => []
                ];
            }
            
            // Use weather helper to get real-time forecast
            $forecast = $this->weatherHelper->getWeatherForecastRange($startDate, $endDate, $location);
            
            // Transform to expected format
            $dryDays = [];
            $rainyDays = [];
            
            foreach ($forecast as $day) {
                $date = $day['date'];
                $rainfall = $day['predicted_rainfall'] ?? 0;
                $wind = $day['predicted_wind'] ?? 0;
                
                // Consider dry if rainfall < 5mm and wind < 25 km/h
                if ($rainfall < 5 && $wind < 25) {
                    $dryDays[] = $date;
                }
                
                // Consider rainy if rainfall >= 10mm
                if ($rainfall >= 10) {
                    $rainyDays[] = $date;
                }
            }
            
            return [
                'forecast_data' => $forecast,
                'dry_days' => $dryDays,
                'rainy_days' => $rainyDays
            ];
            
        } catch (Exception $e) {
            error_log("Error getting weather forecast: " . $e->getMessage());
            // Fallback to neutral forecast
            return [
                'forecast_data' => [],
                'dry_days' => [],
                'rainy_days' => []
            ];
        }
    }
    
    /**
     * Calculate weather score for harvest date
     * @param string $date Y-m-d format
     * @param array $weatherForecast Forecast data from getWeatherForecast()
     * @return int Score 0-100 (higher is better for harvest)
     */
    private function calculateHarvestWeatherScore($date, $weatherForecast) {
        // Find forecast data for this specific date
        $forecastData = $weatherForecast['forecast_data'] ?? [];
        $dayForecast = null;
        
        foreach ($forecastData as $day) {
            if ($day['date'] === $date) {
                $dayForecast = $day;
                break;
            }
        }
        
        if (!$dayForecast) {
            // If no forecast for this date, check if it's in dry/rainy days lists
            if (in_array($date, $weatherForecast['dry_days'] ?? [])) {
                return 100;
            } elseif (in_array($date, $weatherForecast['rainy_days'] ?? [])) {
                return 30;
            }
            return 70; // Neutral if no data
        }
        
        // Score based on actual forecast values
        $rainfall = $dayForecast['predicted_rainfall'] ?? 0;
        $wind = $dayForecast['predicted_wind'] ?? 0;
        
        // Perfect conditions: no rain, low wind
        if ($rainfall < 2 && $wind < 15) {
            return 100;
        }
        
        // Good conditions: light rain (<5mm), moderate wind (<20 km/h)
        if ($rainfall < 5 && $wind < 20) {
            return 85;
        }
        
        // Acceptable: moderate rain (<10mm), moderate wind (<25 km/h)
        if ($rainfall < 10 && $wind < 25) {
            return 70;
        }
        
        // Poor: heavy rain or high wind
        if ($rainfall >= 10 || $wind >= 25) {
            return 30;
        }
        
        // Very poor: very heavy rain (>30mm) or very high wind (>35 km/h)
        if ($rainfall >= 30 || $wind >= 35) {
            return 10;
        }
        
        return 50; // Default neutral score
    }
    
    private function calculatePriceScore($cropName, $date) {
        try {
            $price = $this->getForecastPrice($cropName, $date);
            $currentPrice = $this->getCurrentPrice($cropName);
            
            if ($currentPrice <= 0) {
                return 50; // Neutral score if no valid price
            }
            
            if ($price >= $currentPrice * 1.1) {
                return 100; // 10%+ higher
            } elseif ($price >= $currentPrice) {
                return 80; // Slightly higher
            } elseif ($price >= $currentPrice * 0.9) {
                return 60; // Slightly lower
            }
            return 40; // Much lower
        } catch (Exception $e) {
            error_log("Error in calculatePriceScore: " . $e->getMessage());
            return 50; // Return neutral score on error
        } catch (Error $e) {
            error_log("Fatal error in calculatePriceScore: " . $e->getMessage());
            return 50; // Return neutral score on error
        }
    }
    
    private function calculateMaturityScore($daysFromPlanting, $growthDays) {
        $diff = abs($daysFromPlanting - $growthDays);
        
        if ($diff <= 3) {
            return 100; // Perfect maturity
        } elseif ($diff <= 7) {
            return 80; // Good maturity
        } elseif ($diff <= 10) {
            return 60; // Acceptable
        }
        return 40; // Not ideal
    }
    
    private function calculatePriceRisk($cropName, $date) {
        // Simple risk calculation
        $price = $this->getForecastPrice($cropName, $date);
        $currentPrice = $this->getCurrentPrice($cropName);
        
        if ($price < $currentPrice * 0.9) {
            return 'high';
        } elseif ($price < $currentPrice * 0.95) {
            return 'medium';
        }
        return 'low';
    }
    
    private function explainPricePeak($date, $cropName) {
        $month = (int)date('n', strtotime($date));
        $monthNames = ['', 'January', 'February', 'March', 'April', 'May', 'June', 
                       'July', 'August', 'September', 'October', 'November', 'December'];
        
        return "High demand expected in " . $monthNames[$month] . " due to seasonal patterns";
    }
    
    private function getMarketOverview() {
        return [
            'current_market_conditions' => 'favorable',
            'price_trend' => 'increasing',
            'demand_level' => 'high',
            'competition_level' => 'medium'
        ];
    }
}

// Handle the request
$requestMethod = $_SERVER['REQUEST_METHOD'] ?? 'GET';

try {
    // Clean any buffered output before starting
    if (ob_get_level() > 0) {
        ob_clean();
    }
    
    // Ensure headers are set before any operations
    if (!headers_sent()) {
        header('Content-Type: application/json');
        header('Access-Control-Allow-Origin: *');
        header('Access-Control-Allow-Methods: GET, POST, OPTIONS');
        header('Access-Control-Allow-Headers: Content-Type');
    }
    
    if ($requestMethod === 'GET') {
        try {
            $optimizer = new MarketTimingOptimizer();
            $action = $_GET['action'] ?? null;
            
            // Check if requesting farmers list
            if ($action === 'list_farmers') {
                $result = $optimizer->getFarmersWithCrops();
            } else {
                // Get market timing recommendations
                $userId = $_GET['user_id'] ?? null;
                $result = $optimizer->getMarketTimingRecommendations($userId);
            }
            
            // Clean output again before sending JSON
            if (ob_get_level() > 0) {
                ob_clean();
            }
            
            echo json_encode($result, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
            
        } catch (Exception $e) {
            error_log('Market Timing API Exception in GET handler: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine());
            error_log('Stack trace: ' . $e->getTraceAsString());
            
            if (ob_get_level() > 0) {
                ob_clean();
            }
            if (!headers_sent()) {
                http_response_code(500);
                header('Content-Type: application/json');
            }
            echo json_encode([
                'success' => false,
                'message' => 'Failed to load market timing data: ' . $e->getMessage()
            ], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
        } catch (Error $e) {
            error_log('Market Timing API Fatal Error in GET handler: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine());
            error_log('Stack trace: ' . $e->getTraceAsString());
            
            if (ob_get_level() > 0) {
                ob_clean();
            }
            if (!headers_sent()) {
                http_response_code(500);
                header('Content-Type: application/json');
            }
            echo json_encode([
                'success' => false,
                'message' => 'Fatal error: ' . $e->getMessage()
            ], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
        }
        
    } elseif ($requestMethod === 'POST') {
        try {
            $input = json_decode(file_get_contents('php://input'), true);
            $optimizer = new MarketTimingOptimizer();
            $userId = $input['user_id'] ?? null;
            $result = $optimizer->getMarketTimingRecommendations($userId);
            
            // Clean output again before sending JSON
            if (ob_get_level() > 0) {
                ob_clean();
            }
            
            echo json_encode($result, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
            
        } catch (Exception $e) {
            error_log('Market Timing API Exception in POST handler: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine());
            error_log('Stack trace: ' . $e->getTraceAsString());
            
            if (ob_get_level() > 0) {
                ob_clean();
            }
            if (!headers_sent()) {
                http_response_code(500);
                header('Content-Type: application/json');
            }
            echo json_encode([
                'success' => false,
                'message' => 'Failed to load market timing data: ' . $e->getMessage()
            ], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
        } catch (Error $e) {
            error_log('Market Timing API Fatal Error in POST handler: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine());
            error_log('Stack trace: ' . $e->getTraceAsString());
            
            if (ob_get_level() > 0) {
                ob_clean();
            }
            if (!headers_sent()) {
                http_response_code(500);
                header('Content-Type: application/json');
            }
            echo json_encode([
                'success' => false,
                'message' => 'Fatal error: ' . $e->getMessage()
            ], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
        }
        
    } elseif ($requestMethod === 'OPTIONS') {
        // Handle preflight requests
        if (ob_get_level() > 0) {
            ob_clean();
        }
        if (!headers_sent()) {
            http_response_code(200);
        }
    } else {
        if (ob_get_level() > 0) {
            ob_clean();
        }
        if (!headers_sent()) {
            http_response_code(405);
            header('Content-Type: application/json');
        }
        echo json_encode(['success' => false, 'message' => 'Method not allowed'], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
    }
    
} catch (Exception $e) {
    // Log the full error for debugging
    error_log('Market Timing API Exception (outer): ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine());
    error_log('Stack trace: ' . $e->getTraceAsString());
    
    // Clean output before sending error response
    if (ob_get_level() > 0) {
        ob_clean();
    }
    if (!headers_sent()) {
        http_response_code(500);
        header('Content-Type: application/json');
    }
    echo json_encode([
        'success' => false,
        'message' => 'Failed to load market timing data: ' . $e->getMessage()
    ], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
} catch (Error $e) {
    // Log the full error for debugging
    error_log('Market Timing API Fatal Error (outer): ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine());
    error_log('Stack trace: ' . $e->getTraceAsString());
    
    // Catch fatal errors too
    if (ob_get_level() > 0) {
        ob_clean();
    }
    if (!headers_sent()) {
        http_response_code(500);
        header('Content-Type: application/json');
    }
    echo json_encode([
        'success' => false,
        'message' => 'Fatal error: ' . $e->getMessage()
    ], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
}

// End output buffering if it was started
if (ob_get_level() > 0) {
    ob_end_flush();
}
?>

