<?php
// Start output buffering to catch any unwanted output
if (!ob_get_level()) {
    ob_start();
}

// Disable error display but log errors instead
ini_set('display_errors', 0);
ini_set('log_errors', 1);
error_reporting(E_ALL);

// Set headers first
header('Content-Type: application/json');
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type');

// Require database config
require_once __DIR__ . '/../config/database.php';

// Clean any output that might have been generated by includes
if (ob_get_level() > 0) {
    $output = ob_get_contents();
    if (!empty($output) && trim($output) !== '') {
        // Log any unexpected output
        error_log('Unexpected output before JSON: ' . substr($output, 0, 500));
        ob_clean();
    }
}

class AnalyticsAPI {
    private $conn;
    private $useAggregates;
    
    public function __construct() {
        try {
            $database = new Database();
            $this->conn = $database->getConnection();
            
            if (!$this->conn) {
                throw new Exception('Failed to establish database connection');
            }
            
            // Check if aggregate tables exist
            $this->useAggregates = $this->checkAggregateTablesExist();
        } catch (Exception $e) {
            error_log('AnalyticsAPI constructor error: ' . $e->getMessage());
            throw $e; // Re-throw to be caught by the calling code
        }
    }
    
    /**
     * Check if aggregate tables exist in the database
     */
    private function checkAggregateTablesExist() {
        try {
            $query = "SHOW TABLES LIKE 'daily_weather_aggregates'";
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            return $stmt->rowCount() > 0;
        } catch (Exception $e) {
            return false;
        }
    }
    
    public function getDashboardAnalytics() {
        try {
            // Check if database connection is available
            if (!$this->conn) {
                throw new Exception('Database connection not available');
            }
            
            $analytics = [
                'farmers' => $this->getFarmerAnalytics(),
                'alerts' => $this->getAlertAnalytics(),
                'weather' => $this->getWeatherAnalytics(),
                'crops' => $this->getCropAnalytics(),
                'user_activity' => $this->getUserActivityAnalytics(),
                'overview' => $this->getOverviewStats(),
                'performance' => $this->getPerformanceMetrics(),
                'alert_trends' => $this->getAlertTrends(),
                'crop_distribution' => $this->getCropDistribution()
            ];
            
            return [
                'success' => true,
                'data' => $analytics
            ];
            
        } catch (Exception $e) {
            error_log('Analytics API Error: ' . $e->getMessage());
            return [
                'success' => false,
                'message' => 'Failed to fetch analytics: ' . $e->getMessage(),
                'error_details' => $e->getFile() . ':' . $e->getLine()
            ];
        }
    }
    
    private function getFarmerAnalytics() {
        if ($this->useAggregates) {
            return $this->getFarmerAnalyticsFromAggregates();
        }
        
        // Original query method (fallback)
        // Total farmers from users table (users and farmers are the same - farmers are users with role='farmer')
        $query = "SELECT COUNT(*) as total FROM users WHERE role = 'farmer'";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $totalFarmers = $stmt->fetch()['total'];
        
        // Farmers by location from users table
        $query = "SELECT location, COUNT(*) as count FROM users WHERE role = 'farmer' AND location IS NOT NULL AND location != '' GROUP BY location ORDER BY count DESC LIMIT 10";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $farmersByLocation = $stmt->fetchAll();
        
        // Recent farmers (last 30 days) from users table
        $query = "SELECT COUNT(*) as count FROM users WHERE role = 'farmer' AND created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $recentFarmers = $stmt->fetch()['count'];
        
        // Active farmers (those with alerts in last 30 days)
        $query = "SELECT COUNT(DISTINCT af.farmer_id) as count 
                  FROM alert_farmers af 
                  INNER JOIN alerts a ON af.alert_id = a.id 
                  WHERE a.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $activeFarmers = $stmt->fetch()['count'];
        
        // Farmers registration trend (last 30 days)
        $query = "SELECT DATE(created_at) as date, COUNT(*) as count 
                  FROM users 
                  WHERE role = 'farmer' AND created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
                  GROUP BY DATE(created_at) 
                  ORDER BY date";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $registrationTrend = $stmt->fetchAll();
        
        return [
            'total' => $totalFarmers,
            'recent' => $recentFarmers,
            'active' => $activeFarmers,
            'by_location' => $farmersByLocation,
            'registration_trend' => $registrationTrend,
            'by_crop' => [] // Crop data available in user_crops table
        ];
    }
    
    /**
     * Optimized farmer analytics using aggregate tables
     */
    private function getFarmerAnalyticsFromAggregates() {
        // Get today's farmer statistics
        $query = "SELECT 
                    total_farmers,
                    new_farmers_last_30_days as recent,
                    active_farmers_count as active,
                    location_distribution
                  FROM farmer_statistics_aggregates
                  WHERE aggregate_date = CURDATE()
                  LIMIT 1";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $todayStats = $stmt->fetch();
        
        // Fallback to latest available if today doesn't exist
        if (!$todayStats || !$todayStats['total_farmers']) {
            $query = "SELECT 
                        total_farmers,
                        new_farmers_last_30_days as recent,
                        active_farmers_count as active,
                        location_distribution
                      FROM farmer_statistics_aggregates
                      ORDER BY aggregate_date DESC
                      LIMIT 1";
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            $todayStats = $stmt->fetch();
        }
        
        $totalFarmers = $todayStats['total_farmers'] ?? 0;
        $recentFarmers = $todayStats['recent'] ?? 0;
        $activeFarmers = $todayStats['active'] ?? 0;
        
        // Parse location distribution from JSON
        $farmersByLocation = [];
        if ($todayStats['location_distribution']) {
            $locationDist = json_decode($todayStats['location_distribution'], true);
            if ($locationDist) {
                foreach ($locationDist as $location => $count) {
                    $farmersByLocation[] = ['location' => $location, 'count' => $count];
                }
            }
        }
        
        // If no location data from aggregates, fallback to direct query
        if (empty($farmersByLocation)) {
            $query = "SELECT location, COUNT(*) as count FROM users WHERE role = 'farmer' AND location IS NOT NULL AND location != '' GROUP BY location ORDER BY count DESC LIMIT 10";
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            $farmersByLocation = $stmt->fetchAll();
        }
        
        // Registration trend (last 30 days) from aggregates
        $query = "SELECT 
                    aggregate_date as date,
                    new_farmers_today as count
                  FROM farmer_statistics_aggregates
                  WHERE aggregate_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)
                  ORDER BY aggregate_date";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $registrationTrend = $stmt->fetchAll();
        
        // Fallback if no aggregate data
        if (empty($registrationTrend)) {
            $query = "SELECT DATE(created_at) as date, COUNT(*) as count 
                      FROM users 
                      WHERE role = 'farmer' AND created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
                      GROUP BY DATE(created_at) 
                      ORDER BY date";
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            $registrationTrend = $stmt->fetchAll();
        }
        
        // Fallback for totals if aggregates don't have data
        if ($totalFarmers == 0) {
            $query = "SELECT COUNT(*) as total FROM users WHERE role = 'farmer'";
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            $totalFarmers = $stmt->fetch()['total'];
        }
        
        return [
            'total' => $totalFarmers,
            'recent' => $recentFarmers,
            'active' => $activeFarmers,
            'by_location' => $farmersByLocation,
            'registration_trend' => $registrationTrend,
            'by_crop' => [] // Crop data available in user_crops table
        ];
    }
    
    private function getAlertAnalytics() {
        if ($this->useAggregates) {
            return $this->getAlertAnalyticsFromAggregates();
        }
        
        // Original query method (fallback)
        // Total alerts
        $query = "SELECT COUNT(*) as total FROM alerts";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $totalAlerts = $stmt->fetch()['total'];
        
        // Active alerts
        $query = "SELECT COUNT(*) as count FROM alerts WHERE status = 'active'";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $activeAlerts = $stmt->fetch()['count'];
        
        // Resolved alerts
        $query = "SELECT COUNT(*) as count FROM alerts WHERE status = 'resolved'";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $resolvedAlerts = $stmt->fetch()['count'];
        
        // Cancelled alerts
        $query = "SELECT COUNT(*) as count FROM alerts WHERE status = 'cancelled'";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $cancelledAlerts = $stmt->fetch()['count'];
        
        // Alerts by type
        $query = "SELECT type, COUNT(*) as count FROM alerts GROUP BY type ORDER BY count DESC";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $alertsByType = $stmt->fetchAll();
        
        // Alerts by severity
        $query = "SELECT severity, COUNT(*) as count FROM alerts GROUP BY severity ORDER BY count DESC";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $alertsBySeverity = $stmt->fetchAll();
        
        // Recent alerts (last 7 days)
        $query = "SELECT COUNT(*) as count FROM alerts WHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $recentAlerts = $stmt->fetch()['count'];
        
        // Alerts by status (for pie chart)
        $statusDistribution = [
            ['status' => 'active', 'count' => $activeAlerts],
            ['status' => 'resolved', 'count' => $resolvedAlerts],
            ['status' => 'cancelled', 'count' => $cancelledAlerts]
        ];
        
        // Farmers affected by alerts
        $query = "SELECT COUNT(DISTINCT farmer_id) as affected_farmers FROM alert_farmers";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $affectedFarmers = $stmt->fetch()['affected_farmers'];
        
        return [
            'total' => $totalAlerts,
            'active' => $activeAlerts,
            'resolved' => $resolvedAlerts,
            'cancelled' => $cancelledAlerts,
            'recent' => $recentAlerts,
            'by_type' => $alertsByType,
            'by_severity' => $alertsBySeverity,
            'by_status' => $statusDistribution,
            'affected_farmers' => $affectedFarmers
        ];
    }
    
    /**
     * Optimized alert analytics using aggregate tables
     */
    private function getAlertAnalyticsFromAggregates() {
        // Total alerts (still need from source table for all-time total)
        $query = "SELECT COUNT(*) as total FROM alerts";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $totalAlerts = $stmt->fetch()['total'];
        
        // Get current day aggregates
        $query = "SELECT 
                    SUM(total_alerts) as total_recent,
                    SUM(active_count) as active,
                    SUM(resolved_count) as resolved,
                    SUM(cancelled_count) as cancelled
                  FROM alert_statistics_aggregates
                  WHERE aggregate_date = CURDATE()";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $todayStats = $stmt->fetch();
        
        // Get all-time stats from aggregates (sum all dates)
        $query = "SELECT 
                    SUM(active_count) as active_all,
                    SUM(resolved_count) as resolved_all,
                    SUM(cancelled_count) as cancelled_all
                  FROM alert_statistics_aggregates";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $allTimeStats = $stmt->fetch();
        
        // Use all-time stats if available, otherwise use today's
        $activeAlerts = $allTimeStats['active_all'] ?? $todayStats['active'] ?? 0;
        $resolvedAlerts = $allTimeStats['resolved_all'] ?? $todayStats['resolved'] ?? 0;
        $cancelledAlerts = $allTimeStats['cancelled_all'] ?? $todayStats['cancelled'] ?? 0;
        
        // Recent alerts (last 7 days)
        $query = "SELECT SUM(total_alerts) as count 
                  FROM alert_statistics_aggregates
                  WHERE aggregate_date >= DATE_SUB(NOW(), INTERVAL 7 DAY)";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $recentAlerts = $stmt->fetch()['count'] ?? 0;
        
        // Parse type and severity distributions from JSON
        $query = "SELECT type_distribution, severity_distribution 
                  FROM alert_statistics_aggregates
                  WHERE aggregate_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)
                  AND (type_distribution IS NOT NULL OR severity_distribution IS NOT NULL)";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $distRows = $stmt->fetchAll();
        
        // Aggregate type counts
        $typeCounts = [];
        $severityCounts = [];
        foreach ($distRows as $row) {
            $typeDist = json_decode($row['type_distribution'] ?? '{}', true);
            $severityDist = json_decode($row['severity_distribution'] ?? '{}', true);
            
            if ($typeDist) {
                foreach ($typeDist as $type => $count) {
                    $typeCounts[$type] = ($typeCounts[$type] ?? 0) + $count;
                }
            }
            if ($severityDist) {
                foreach ($severityDist as $severity => $count) {
                    $severityCounts[$severity] = ($severityCounts[$severity] ?? 0) + $count;
                }
            }
        }
        
        arsort($typeCounts);
        arsort($severityCounts);
        
        $alertsByType = [];
        foreach ($typeCounts as $type => $count) {
            $alertsByType[] = ['type' => $type, 'count' => $count];
        }
        
        $alertsBySeverity = [];
        foreach ($severityCounts as $severity => $count) {
            $alertsBySeverity[] = ['severity' => $severity, 'count' => $count];
        }
        
        // If no aggregate data, fallback to direct query
        if (empty($alertsByType)) {
            $query = "SELECT type, COUNT(*) as count FROM alerts GROUP BY type ORDER BY count DESC";
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            $alertsByType = $stmt->fetchAll();
        }
        
        if (empty($alertsBySeverity)) {
            $query = "SELECT severity, COUNT(*) as count FROM alerts GROUP BY severity ORDER BY count DESC";
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            $alertsBySeverity = $stmt->fetchAll();
        }
        
        // Farmers affected by alerts (from aggregates)
        $query = "SELECT MAX(affected_farmers_count) as affected_farmers 
                  FROM alert_statistics_aggregates
                  WHERE aggregate_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $affectedFarmers = $stmt->fetch()['affected_farmers'] ?? 0;
        
        // Fallback if no aggregate data
        if ($affectedFarmers == 0) {
            $query = "SELECT COUNT(DISTINCT farmer_id) as affected_farmers FROM alert_farmers";
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            $affectedFarmers = $stmt->fetch()['affected_farmers'];
        }
        
        $statusDistribution = [
            ['status' => 'active', 'count' => $activeAlerts],
            ['status' => 'resolved', 'count' => $resolvedAlerts],
            ['status' => 'cancelled', 'count' => $cancelledAlerts]
        ];
        
        return [
            'total' => $totalAlerts,
            'active' => $activeAlerts,
            'resolved' => $resolvedAlerts,
            'cancelled' => $cancelledAlerts,
            'recent' => $recentAlerts,
            'by_type' => $alertsByType,
            'by_severity' => $alertsBySeverity,
            'by_status' => $statusDistribution,
            'affected_farmers' => $affectedFarmers
        ];
    }
    
    private function getWeatherAnalytics() {
        if ($this->useAggregates) {
            return $this->getWeatherAnalyticsFromAggregates();
        }
        
        // Original query method (fallback)
        // Weather data count
        $query = "SELECT COUNT(*) as total FROM weather_data";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $totalWeatherRecords = $stmt->fetch()['total'];
        
        // Average temperature (last 30 days)
        $query = "SELECT AVG(temperature) as avg_temp FROM weather_data WHERE recorded_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $avgTemperature = $stmt->fetch()['avg_temp'];
        
        // Average humidity (last 30 days)
        $query = "SELECT AVG(humidity) as avg_humidity FROM weather_data WHERE recorded_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $avgHumidity = $stmt->fetch()['avg_humidity'];
        
        // Total rainfall (last 30 days)
        $query = "SELECT SUM(rainfall) as total_rainfall FROM weather_data WHERE recorded_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $totalRainfall = $stmt->fetch()['total_rainfall'];
        
        // Weather conditions distribution
        $query = "SELECT `condition`, COUNT(*) as count FROM weather_data WHERE recorded_at >= DATE_SUB(NOW(), INTERVAL 30 DAY) GROUP BY `condition` ORDER BY count DESC";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $weatherConditions = $stmt->fetchAll();
        
        // Daily weather data for chart (last 7 days)
        $query = "SELECT DATE(recorded_at) as date, AVG(temperature) as avg_temp, AVG(humidity) as avg_humidity, SUM(rainfall) as total_rainfall FROM weather_data WHERE recorded_at >= DATE_SUB(NOW(), INTERVAL 7 DAY) GROUP BY DATE(recorded_at) ORDER BY date";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $dailyWeather = $stmt->fetchAll();
        
        return [
            'total_records' => $totalWeatherRecords,
            'avg_temperature' => round($avgTemperature, 1),
            'avg_humidity' => round($avgHumidity, 1),
            'total_rainfall' => round($totalRainfall, 1),
            'conditions' => $weatherConditions,
            'daily_data' => $dailyWeather
        ];
    }
    
    /**
     * Optimized weather analytics using aggregate tables
     */
    private function getWeatherAnalyticsFromAggregates() {
        // Total weather records (still need from source table)
        $query = "SELECT COUNT(*) as total FROM weather_data";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $totalWeatherRecords = $stmt->fetch()['total'];
        
        // Get 30-day aggregates
        $query = "SELECT 
                    AVG(avg_temperature) as avg_temp,
                    AVG(avg_humidity) as avg_humidity,
                    SUM(total_rainfall) as total_rainfall,
                    SUM(record_count) as total_records_30d
                  FROM daily_weather_aggregates
                  WHERE aggregate_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $thirtyDayStats = $stmt->fetch();
        
        // Parse condition distribution from JSON
        $query = "SELECT condition_distribution 
                  FROM daily_weather_aggregates
                  WHERE aggregate_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)
                  AND condition_distribution IS NOT NULL";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $conditionRows = $stmt->fetchAll();
        
        // Aggregate condition counts from all days
        $conditionCounts = [];
        foreach ($conditionRows as $row) {
            $dist = json_decode($row['condition_distribution'], true);
            if ($dist) {
                foreach ($dist as $condition => $count) {
                    $conditionCounts[$condition] = ($conditionCounts[$condition] ?? 0) + $count;
                }
            }
        }
        arsort($conditionCounts);
        $weatherConditions = [];
        foreach ($conditionCounts as $condition => $count) {
            $weatherConditions[] = ['condition' => $condition, 'count' => $count];
        }
        
        // Daily weather data for chart (last 7 days) - from aggregates
        $query = "SELECT 
                    aggregate_date as date,
                    avg_temperature as avg_temp,
                    avg_humidity,
                    total_rainfall
                  FROM daily_weather_aggregates
                  WHERE aggregate_date >= DATE_SUB(NOW(), INTERVAL 7 DAY)
                  ORDER BY aggregate_date";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $dailyWeather = $stmt->fetchAll();
        
        return [
            'total_records' => $totalWeatherRecords,
            'avg_temperature' => round($thirtyDayStats['avg_temp'] ?: 0, 1),
            'avg_humidity' => round($thirtyDayStats['avg_humidity'] ?: 0, 1),
            'total_rainfall' => round($thirtyDayStats['total_rainfall'] ?: 0, 1),
            'conditions' => $weatherConditions,
            'daily_data' => $dailyWeather
        ];
    }
    
    private function getCropAnalytics() {
        // Get crop recommendations data
        $cropData = [
            'total_crops' => 32, // Based on our expanded crop database
            'recommended_crops' => [
                ['name' => 'Rice', 'suitability' => 'Excellent', 'score' => 85],
                ['name' => 'Corn', 'suitability' => 'Good', 'score' => 78],
                ['name' => 'Tomato', 'suitability' => 'Good', 'score' => 72],
                ['name' => 'Eggplant', 'suitability' => 'Fair', 'score' => 65],
                ['name' => 'Okra', 'suitability' => 'Good', 'score' => 70],
                ['name' => 'Squash', 'suitability' => 'Fair', 'score' => 60],
                ['name' => 'Pepper', 'suitability' => 'Good', 'score' => 68],
                ['name' => 'Cabbage', 'suitability' => 'Poor', 'score' => 45]
            ],
            'crop_demand' => [
                ['crop' => 'Rice', 'demand' => 'Very High', 'price' => 'High'],
                ['crop' => 'Corn', 'demand' => 'High', 'price' => 'Medium'],
                ['crop' => 'Tomato', 'demand' => 'High', 'price' => 'Medium'],
                ['crop' => 'Eggplant', 'demand' => 'Medium', 'price' => 'Medium'],
                ['crop' => 'Okra', 'demand' => 'Medium', 'price' => 'Low'],
                ['crop' => 'Squash', 'demand' => 'Medium', 'price' => 'Low'],
                ['crop' => 'Pepper', 'demand' => 'High', 'price' => 'High'],
                ['crop' => 'Cabbage', 'demand' => 'High', 'price' => 'Medium']
            ]
        ];
        
        return $cropData;
    }
    
    private function getCropDistribution() {
        try {
            // Check if user_crops table exists
            $query = "SHOW TABLES LIKE 'user_crops'";
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            $tableExists = $stmt->rowCount() > 0;
            
            if ($tableExists) {
                // Get crop distribution from user_crops table
                $query = "SELECT crop_name, COUNT(*) as count FROM user_crops GROUP BY crop_name ORDER BY count DESC LIMIT 10";
                $stmt = $this->conn->prepare($query);
                $stmt->execute();
                $cropDistribution = $stmt->fetchAll();
                
                // Get total farmers with crops
                $query = "SELECT COUNT(DISTINCT user_id) as total FROM user_crops";
                $stmt = $this->conn->prepare($query);
                $stmt->execute();
                $totalFarmersWithCrops = $stmt->fetch()['total'];
            } else {
                // Fallback: try to parse crops from farmers table
                $query = "SELECT crops FROM farmers WHERE crops IS NOT NULL AND crops != ''";
                $stmt = $this->conn->prepare($query);
                $stmt->execute();
                $cropsData = $stmt->fetchAll();
                
                $cropCounts = [];
                foreach ($cropsData as $row) {
                    $crops = explode(',', $row['crops']);
                    foreach ($crops as $crop) {
                        $crop = trim($crop);
                        if (!empty($crop)) {
                            $cropCounts[$crop] = isset($cropCounts[$crop]) ? $cropCounts[$crop] + 1 : 1;
                        }
                    }
                }
                
                arsort($cropCounts);
                $cropDistribution = [];
                foreach ($cropCounts as $crop => $count) {
                    $cropDistribution[] = ['crop_name' => $crop, 'count' => $count];
                }
                $cropDistribution = array_slice($cropDistribution, 0, 10);
                $totalFarmersWithCrops = count($cropsData);
            }
            
            return [
                'distribution' => $cropDistribution,
                'total_farmers_with_crops' => $totalFarmersWithCrops
            ];
        } catch (Exception $e) {
            return [
                'distribution' => [],
                'total_farmers_with_crops' => 0
            ];
        }
    }
    
    private function getAlertTrends() {
        // Alerts created per day (last 30 days)
        $query = "SELECT DATE(created_at) as date, COUNT(*) as count, 
                  SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active_count,
                  SUM(CASE WHEN status = 'resolved' THEN 1 ELSE 0 END) as resolved_count
                  FROM alerts 
                  WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
                  GROUP BY DATE(created_at) 
                  ORDER BY date";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $dailyAlerts = $stmt->fetchAll();
        
        // Alert resolution time (average hours to resolve)
        $query = "SELECT AVG(TIMESTAMPDIFF(HOUR, created_at, updated_at)) as avg_resolution_hours
                  FROM alerts 
                  WHERE status = 'resolved' AND updated_at > created_at";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $avgResolutionTime = $stmt->fetch()['avg_resolution_hours'];
        
        // Alerts by hour of day (to see peak alert times)
        $query = "SELECT HOUR(created_at) as hour, COUNT(*) as count
                  FROM alerts 
                  WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
                  GROUP BY HOUR(created_at)
                  ORDER BY hour";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $alertsByHour = $stmt->fetchAll();
        
        return [
            'daily_trends' => $dailyAlerts,
            'avg_resolution_hours' => round($avgResolutionTime ?: 0, 1),
            'by_hour' => $alertsByHour
        ];
    }
    
    private function getPerformanceMetrics() {
        // Database performance metrics
        $metrics = [];
        
        // Alert response rate (alerts resolved within 24 hours)
        $query = "SELECT COUNT(*) as total_resolved,
                  SUM(CASE WHEN TIMESTAMPDIFF(HOUR, created_at, updated_at) <= 24 THEN 1 ELSE 0 END) as resolved_24h
                  FROM alerts 
                  WHERE status = 'resolved'";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $responseData = $stmt->fetch();
        $responseRate = $responseData['total_resolved'] > 0 
            ? round(($responseData['resolved_24h'] / $responseData['total_resolved']) * 100, 1)
            : 0;
        
        // Weather data collection rate (records per day average)
        $query = "SELECT AVG(daily_count) as avg_daily_records FROM (
                    SELECT DATE(recorded_at) as date, COUNT(*) as daily_count
                    FROM weather_data
                    WHERE recorded_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
                    GROUP BY DATE(recorded_at)
                  ) as daily_counts";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $avgDailyRecords = round($stmt->fetch()['avg_daily_records'] ?: 0, 1);
        
        // System uptime (based on weather data consistency)
        $query = "SELECT COUNT(DISTINCT DATE(recorded_at)) as active_days
                  FROM weather_data
                  WHERE recorded_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $activeDays = $stmt->fetch()['active_days'];
        $uptimePercent = round(($activeDays / 30) * 100, 1);
        
        // Alert accuracy (percentage of alerts that were resolved vs cancelled)
        $query = "SELECT 
                  COUNT(*) as total,
                  SUM(CASE WHEN status = 'resolved' THEN 1 ELSE 0 END) as resolved,
                  SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) as cancelled
                  FROM alerts";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $accuracyData = $stmt->fetch();
        $accuracyRate = $accuracyData['total'] > 0
            ? round(($accuracyData['resolved'] / $accuracyData['total']) * 100, 1)
            : 0;
        
        return [
            'alert_response_rate' => $responseRate,
            'avg_daily_weather_records' => $avgDailyRecords,
            'system_uptime_percent' => $uptimePercent,
            'alert_accuracy_rate' => $accuracyRate,
            'active_days' => $activeDays
        ];
    }
    
    private function getUserActivityAnalytics() {
        // Get user activity data based on actual database records
        // Users and farmers are the same - farmers are users with role='farmer'
        
        // Daily user registrations (last 7 days) - from users table
        $query = "SELECT DATE(created_at) as date, COUNT(*) as count FROM users WHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY) GROUP BY DATE(created_at) ORDER BY date";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $dailyRegistrations = $stmt->fetchAll();
        
        // Create registration map
        $combinedRegistrations = [];
        foreach ($dailyRegistrations as $reg) {
            $combinedRegistrations[$reg['date']] = $reg['count'];
        }
        
        // Create 7-day array with actual data
        $last7Days = [];
        for ($i = 6; $i >= 0; $i--) {
            $date = date('Y-m-d', strtotime("-$i days"));
            $dayName = date('D', strtotime($date));
            $count = isset($combinedRegistrations[$date]) ? $combinedRegistrations[$date] : 0;
            $last7Days[] = [
                'day' => $dayName,
                'date' => $date,
                'count' => $count
            ];
        }
        
        // User activity based on recent alerts (users who have alerts)
        $query = "SELECT COUNT(DISTINCT af.farmer_id) as active_farmers FROM alert_farmers af 
                 INNER JOIN alerts a ON af.alert_id = a.id 
                 WHERE a.created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $activeFarmers = $stmt->fetch()['active_farmers'];
        
        // More accurate active users calculation
        // Try to use activity log first, fallback to recent registrations
        $activeUsers = 0;
        
        try {
            // Check if activity log table exists and has data
            $query = "SELECT COUNT(DISTINCT user_id) as count FROM user_activity_log WHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)";
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            $activeUsers = $stmt->fetch()['count'];
        } catch (Exception $e) {
            // If activity log doesn't exist or has no data, use conservative approach
            // Only count users who were created very recently (within last 7 days) as "active"
            $query = "SELECT COUNT(*) as count FROM users WHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)";
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            $activeUsers = $stmt->fetch()['count'];
        }
        
        // User roles distribution (users and farmers are the same)
        $query = "SELECT role, COUNT(*) as count FROM users GROUP BY role";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $userRoles = $stmt->fetchAll();
        
        return [
            'daily_registrations' => $last7Days,
            'active_farmers' => $activeFarmers,
            'active_users' => $activeUsers,
            'user_roles' => $userRoles,
            'total_users' => array_sum(array_column($userRoles, 'count'))
        ];
    }
    
    private function getOverviewStats() {
        // Quick stats for dashboard
        // Users and farmers are the same - farmers are users with role='farmer'
        $stats = [];
        
        // Total farmers from users table (role = 'farmer')
        $query = "SELECT COUNT(*) as count FROM users WHERE role = 'farmer'";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $stats['total_farmers'] = $stmt->fetch()['count'];
        
        // Active alerts
        $query = "SELECT COUNT(*) as count FROM alerts WHERE status = 'active'";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $stats['active_alerts'] = $stmt->fetch()['count'];
        
        // Weather records today
        $query = "SELECT COUNT(*) as count FROM weather_data WHERE DATE(recorded_at) = CURDATE()";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $stats['weather_records_today'] = $stmt->fetch()['count'];
        
        // Recent farmers (last 7 days) - from users table
        $query = "SELECT COUNT(*) as count FROM users WHERE role = 'farmer' AND created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();
        $stats['new_farmers_week'] = $stmt->fetch()['count'];
        
        return $stats;
    }
}

// Handle the request
$requestMethod = $_SERVER['REQUEST_METHOD'] ?? 'GET';

if ($requestMethod === 'GET') {
    try {
        // Clean any buffered output before starting
        if (ob_get_level() > 0) {
            ob_clean();
        }
        
        $analytics = new AnalyticsAPI();
        $result = $analytics->getDashboardAnalytics();
        
        // Clean output again before sending JSON
        if (ob_get_level() > 0) {
            ob_clean();
        }
        
        // Ensure we're sending clean JSON
        header('Content-Type: application/json');
        echo json_encode($result, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
        
    } catch (Exception $e) {
        // Clean output before sending error response
        if (ob_get_level() > 0) {
            ob_clean();
        }
        http_response_code(500);
        header('Content-Type: application/json');
        echo json_encode([
            'success' => false,
            'message' => 'Failed to initialize analytics: ' . $e->getMessage()
        ], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
    } catch (Error $e) {
        // Catch fatal errors too
        if (ob_get_level() > 0) {
            ob_clean();
        }
        http_response_code(500);
        header('Content-Type: application/json');
        echo json_encode([
            'success' => false,
            'message' => 'Fatal error: ' . $e->getMessage()
        ], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
    }
} else if ($requestMethod === 'OPTIONS') {
    // Handle preflight requests
    if (ob_get_level() > 0) {
        ob_clean();
    }
    http_response_code(200);
} else {
    if (ob_get_level() > 0) {
        ob_clean();
    }
    http_response_code(405);
    header('Content-Type: application/json');
    echo json_encode([
        'success' => false,
        'message' => 'Method not allowed'
    ], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
}

// End output buffering if it was started
if (ob_get_level() > 0) {
    ob_end_flush();
}
?>
